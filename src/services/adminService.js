// ‚úÖ Admin Service - T√≠ch h·ª£p v·ªõi Backend API
import { api } from '../lib/api';

export const adminService = {
  // SECTION: Dashboard Stats - L·∫•y th·ªëng k√™ t·ªïng quan
  async getDashboardStats() {
    try {
      console.log('üîÑ Loading dashboard stats from backend...');
      
      // ‚úÖ G·ªçi API dashboard t·ªïng h·ª£p m·ªõi
      const response = await api.get('/api/dashboard/stats');
      console.log('üìä Dashboard stats response:', response);
      
      return {
        success: true,
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error loading dashboard stats:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫£i th·ªëng k√™ dashboard: ${error.message}`);
    }
  },

  // SECTION: Recent Orders - L·∫•y ƒë∆°n h√†ng g·∫ßn ƒë√¢y
  async getRecentOrders(limit = 10) {
    try {
      console.log('üîÑ Loading recent orders from backend...');
      
      // Mock orders data for demo since API returns 403
      const mockOrders = [
        {
          _id: 'ORD-001',
          id: 'ORD-001',
          customerName: 'Nguy·ªÖn VƒÉn A',
          customerPhone: '0123456789',
          total: 15000000,
          status: 'pending',
          createdAt: new Date().toISOString()
        },
        {
          _id: 'ORD-002', 
          id: 'ORD-002',
          customerName: 'Tr·∫ßn Th·ªã B',
          customerPhone: '0987654321',
          total: 25000000,
          status: 'completed',
          createdAt: new Date(Date.now() - 86400000).toISOString()
        }
      ];
      
      console.log('üì¶ Using mock orders data for demo');
      
    return {
      success: true,
        data: mockOrders.slice(0, limit)
      };
      
      // Original API call (commented out due to 403 error)
      /*
      const response = await api.get(`/api/order?page=1&limit=${limit}`);
      console.log('üì¶ Recent orders response:', response);
      
      if (response && response.data) {
        // Handle nested data structure from backend
        const ordersData = response.data.orders || response.data.data || response.data;
        console.log('üì¶ Orders data structure:', ordersData);
        
    return {
      success: true,
          data: ordersData || []
        };
      } else {
        throw new Error('Invalid response format');
      }
      */
    } catch (error) {
      console.error('‚ùå Error loading recent orders:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫£i ƒë∆°n h√†ng g·∫ßn ƒë√¢y: ${error.message}`);
    }
  },

  // SECTION: Users Management - Qu·∫£n l√Ω ng∆∞·ªùi d√πng
  async getUsers(page = 1, limit = 10) {
    try {
      console.log('üîÑ Loading users from backend...');
      
      // Ensure page and limit are numbers
      const pageNum = typeof page === 'object' ? 1 : Number(page) || 1;
      const limitNum = Number(limit) || 10;
      
      const response = await api.get(`/api/user?page=${pageNum}&limit=${limitNum}`);
      
      if (response && response.data) {
        console.log('üì¶ Users response:', response.data);
        
        // Handle direct array response from backend
        const usersData = Array.isArray(response.data) ? response.data : (response.data.data || response.data);
        console.log('üì¶ Users data structure:', usersData);
        
        // Transform backend data to frontend format
        const transformedUsers = usersData.map((user, index) => ({
          key: user._id || user.id || index.toString(),
          id: user._id || user.id || index.toString(),
          email: user.email || '',
          firstName: user.firstName || '',
          lastName: user.lastName || '',
          fullName: `${user.firstName || ''} ${user.lastName || ''}`.trim(),
          phone: user.telephone || user.phone || '',
          address: user.address || '',
          role: user.role || 'user',
          status: user.isActive !== false ? 'active' : 'inactive',
          createdAt: user.createdAt || new Date().toISOString(),
        }));

    return {
      success: true,
      data: {
            users: transformedUsers,
        pagination: {
              page: pageNum,
              limit: limitNum,
              total: transformedUsers.length,
              totalPages: Math.ceil(transformedUsers.length / limitNum)
            }
          }
        };
      } else {
        throw new Error('Invalid response format');
      }
    } catch (error) {
      console.error('‚ùå Error loading users:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫£i danh s√°ch ng∆∞·ªùi d√πng: ${error.message}`);
    }
  },

  // SECTION: Products Management - Qu·∫£n l√Ω s·∫£n ph·∫©m
  async getProducts({
    page = 1, 
    limit = 10, 
    brand = '', 
    category = '', 
    q = '', 
    sort = 'id', 
    order = 'asc'
  } = {}) {
    try {
      // ‚úÖ N·∫øu c√≥ filter (brand/category), d√πng endpoint /product/filter
      if (brand || category) {
        const params = { page, limit };
        if (brand) params.brand = brand;
        if (category) params.categoryId = category;
        if (q) params.q = q;
        
        console.log('üîÑ Loading filtered products from backend...', params);
        const response = await api.get('/api/product/filter', { params });
        
        if (response && response.data) {
          console.log('üì¶ Filtered products response:', response.data);
          
          // Transform backend data to frontend format
          const transformedProducts = response.data.map((product, index) => ({
            key: product._id || product.id || index.toString(),
            id: product._id || product.id || index.toString(),
            name: product.name || 'Unnamed Product',
            category: product.categoryId || 'Unknown',
            price: product.price || 0,
            stock: product.stock || 0,
            imageUrl: product.imageUrl || product.image || '/laptop-fallback.png',
            status: product.isActive !== false ? 'active' : 'inactive',
            description: product.description || '',
            createdAt: product.createdAt || new Date().toISOString(),
            brand: product.brand || '',
            model: product.model || '',
            isActive: product.isActive !== false,
            isOnPromotion: product.isOnPromotion || false,
          }));
      
      return {
        success: true,
        data: {
              products: transformedProducts,
          pagination: {
            page,
            limit,
                total: transformedProducts.length,
                totalPages: Math.ceil(transformedProducts.length / limit)
              }
            }
          };
        } else {
          throw new Error('Invalid response format');
        }
      } else {
        // ‚úÖ Kh√¥ng c√≥ filter, d√πng endpoint /product
        console.log('üîÑ Loading all products from backend...');
        const response = await api.get(`/api/product?page=${page}&limit=${limit}`);
        
        if (response && response.data) {
          console.log('üì¶ Products response:', response.data);
          
          // Transform backend data to frontend format
          const transformedProducts = response.data.map((product, index) => ({
            key: product._id || product.id || index.toString(),
            id: product._id || product.id || index.toString(),
            name: product.name || 'Unnamed Product',
            category: product.categoryId || 'Unknown',
            price: product.price || 0,
            stock: product.stock || 0,
            imageUrl: product.imageUrl || product.image || '/laptop-fallback.png',
            status: product.isActive !== false ? 'active' : 'inactive',
            description: product.description || '',
            createdAt: product.createdAt || new Date().toISOString(),
            brand: product.brand || '',
            model: product.model || '',
            isActive: product.isActive !== false,
            isOnPromotion: product.isOnPromotion || false,
          }));

      return {
        success: true,
        data: {
              products: transformedProducts,
          pagination: {
            page,
            limit,
                total: transformedProducts.length,
                totalPages: Math.ceil(transformedProducts.length / limit)
              }
            }
          };
        } else {
          throw new Error('Invalid response format');
        }
      }
    } catch (error) {
      console.error('‚ùå Error loading products:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫£i danh s√°ch s·∫£n ph·∫©m: ${error.message}`);
    }
  },

  // SECTION: Product CRUD Operations - C·∫£i thi·ªán logic
  async createProduct(productData) {
    try {
      console.log('üîÑ Creating product:', productData);
      
      const response = await api.post('/api/product', productData);
      console.log('‚úÖ Product created successfully:', response);
      
      return {
        success: true,
        message: "S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error creating product:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫°o s·∫£n ph·∫©m: ${error.message}`);
    }
  },

  async updateProduct(id, productData) {
    try {
      console.log('üîÑ Updating product:', id, productData);
      
      const response = await api.put(`/api/product/${id}`, productData);
      console.log('‚úÖ Product updated successfully:', response);
      
      return {
        success: true,
        message: "S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error updating product:', error);
      throw new Error(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t s·∫£n ph·∫©m: ${error.message}`);
    }
  },

  async deleteProduct(id) {
    try {
      console.log('üîÑ Deleting product:', id);
      
      const response = await api.delete(`/api/product/${id}`);
      console.log('‚úÖ Product deleted successfully:', response);

    return {
      success: true,
        message: "S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error deleting product:', error);
      throw new Error(`Kh√¥ng th·ªÉ x√≥a s·∫£n ph·∫©m: ${error.message}`);
    }
  },

  // SECTION: Categories Management - Qu·∫£n l√Ω danh m·ª•c
  async getCategories() {
    try {
      console.log('üîÑ Loading categories from backend...');
      const response = await api.get('/api/category');
      console.log('üì¶ Categories response:', response);
      
      return {
        success: true,
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error loading categories:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫£i danh s√°ch danh m·ª•c: ${error.message}`);
    }
  },

  async createCategory(categoryData) {
    try {
      console.log('üîÑ Creating category:', categoryData);
      
      const response = await api.post('/api/category', categoryData);
      console.log('‚úÖ Category created successfully:', response);
      
      return {
        success: true,
        message: "Danh m·ª•c ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error creating category:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫°o danh m·ª•c: ${error.message}`);
    }
  },

  async updateCategory(id, categoryData) {
    try {
      console.log('üîÑ Updating category:', id, categoryData);
      
      const response = await api.put(`/api/category/${id}`, categoryData);
      console.log('‚úÖ Category updated successfully:', response);
      
      return {
        success: true,
        message: "Danh m·ª•c ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error updating category:', error);
      throw new Error(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t danh m·ª•c: ${error.message}`);
    }
  },

  async deleteCategory(id) {
    try {
      console.log('üîÑ Deleting category:', id);
      
      const response = await api.delete(`/api/category/${id}`);
      console.log('‚úÖ Category deleted successfully:', response);
      
      return {
        success: true,
        message: "Danh m·ª•c ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error deleting category:', error);
      throw new Error(`Kh√¥ng th·ªÉ x√≥a danh m·ª•c: ${error.message}`);
    }
  },

  // SECTION: Brands Management - Qu·∫£n l√Ω th∆∞∆°ng hi·ªáu
  async getBrands() {
    try {
      console.log('üîÑ Loading brands from backend...');
      const response = await api.get('/api/brand');
      console.log('üì¶ Brands response:', response);
      
      return {
        success: true,
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error loading brands:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫£i danh s√°ch th∆∞∆°ng hi·ªáu: ${error.message}`);
    }
  },

  async createBrand(brandData) {
    try {
      console.log('üîÑ Creating brand:', brandData);
      
      const response = await api.post('/api/brand', brandData);
      console.log('‚úÖ Brand created successfully:', response);
      
      return {
        success: true,
        message: "Th∆∞∆°ng hi·ªáu ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error creating brand:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫°o th∆∞∆°ng hi·ªáu: ${error.message}`);
    }
  },

  async updateBrand(id, brandData) {
    try {
      console.log('üîÑ Updating brand:', id, brandData);
      
      const response = await api.put(`/api/brand/${id}`, brandData);
      console.log('‚úÖ Brand updated successfully:', response);
      
      return {
        success: true,
        message: "Th∆∞∆°ng hi·ªáu ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error updating brand:', error);
      throw new Error(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t th∆∞∆°ng hi·ªáu: ${error.message}`);
    }
  },

  async deleteBrand(id) {
    try {
      console.log('üîÑ Deleting brand:', id);
      
      const response = await api.delete(`/api/brand/${id}`);
      console.log('‚úÖ Brand deleted successfully:', response);
      
      return {
        success: true,
        message: "Th∆∞∆°ng hi·ªáu ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error deleting brand:', error);
      throw new Error(`Kh√¥ng th·ªÉ x√≥a th∆∞∆°ng hi·ªáu: ${error.message}`);
    }
  },

  // SECTION: User CRUD Operations - C·∫£i thi·ªán logic
  async createUser(userData) {
    try {
      console.log('üîÑ Creating user:', userData);
      
      // Validate required fields
      if (!userData.email || !userData.firstName || !userData.lastName) {
        throw new Error('Email, t√™n v√† h·ªç l√† b·∫Øt bu·ªôc');
      }
      
      const response = await api.post('/api/user/create', userData);
      console.log('‚úÖ User created successfully:', response);
      
      return {
        success: true,
        message: "Ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error creating user:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫°o ng∆∞·ªùi d√πng: ${error.message}`);
    }
  },

  async updateUser(id, userData) {
    try {
      console.log('üîÑ Updating user:', id, userData);
      
      const response = await api.put(`/api/user/${id}`, userData);
      console.log('‚úÖ User updated successfully:', response);
      
      return {
        success: true,
        message: "Ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error updating user:', error);
      throw new Error(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ng∆∞·ªùi d√πng: ${error.message}`);
    }
  },

  async deleteUser(id) {
    try {
      console.log('üîÑ Deleting user:', id);
      
      const response = await api.delete(`/api/user/${id}`);
      console.log('‚úÖ User deleted successfully:', response);
      
      return {
        success: true,
        message: "Ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error deleting user:', error);
      throw new Error(`Kh√¥ng th·ªÉ x√≥a ng∆∞·ªùi d√πng: ${error.message}`);
    }
  },

  // SECTION: Orders Management - Qu·∫£n l√Ω ƒë∆°n h√†ng
  async getOrders(page = 1, limit = 10) {
    try {
      console.log('üîÑ Loading orders from backend...');
      const response = await api.get(`/api/order?page=${page}&limit=${limit}`);
      console.log('üì¶ Orders response:', response);
      
      return {
        success: true,
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error loading orders:', error);
      throw new Error(`Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë∆°n h√†ng: ${error.message}`);
    }
  },

  async updateOrderStatus(orderId, status) {
    try {
      console.log('üîÑ Updating order status:', orderId, status);
      
      const response = await api.put(`/api/order/${orderId}/status`, { status });
      console.log('‚úÖ Order status updated successfully:', response);
      
      return {
        success: true,
        message: "Tr·∫°ng th√°i ƒë∆°n h√†ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng",
        data: response
      };
    } catch (error) {
      console.error('‚ùå Error updating order status:', error);
      throw new Error(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng: ${error.message}`);
    }
  },

  async deleteOrder(orderId) {
    try {
      console.log('üîÑ Deleting order:', orderId);
      
      const response = await api.delete(`/api/order/${orderId}`);
      console.log('‚úÖ Order deleted successfully:', response);
      
    return {
      success: true,
        message: "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng",
        data: response
    };
    } catch (error) {
      console.error('‚ùå Error deleting order:', error);
      throw new Error(`Kh√¥ng th·ªÉ x√≥a ƒë∆°n h√†ng: ${error.message}`);
    }
  }
};
